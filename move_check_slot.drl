# =========================
# DRL merged program
# Shelf pick -> align/inspect -> place
# =========================

DX = 60.0
DY = 60.0
DZ = 60.0

Z_UP   = 100.0
X_PULL = -100.0
INSPECT_TIME = 4.0

V_FAST = 70
A_FAST = 70
V_SLOW = 30
A_SLOW = 30

# Align motion
V_ALIGN = 50
A_ALIGN = 50

HOME_P = posx(367.22, 3.83, 201.28, 158.41, 179.96, 158.79)

S1_BASE = (750.39,  200.46, 250.92,   2.36,   88.13,   2.04)
S2_BASE = (429.80, -258.59,  86.78, 115.36, -179.93, 116.26)
S3_BASE = (429.06,  213.83,  87.04, 154.82,  179.97, 155.23)

S1_AXIS = 'z'
S2_AXIS = 'x'
S3_AXIS = 'x'


# =========================
# Gripper
# =========================
def open_gripper():
    # 너가 쓰던 방식: 채널2 펄스
    set_digital_output(2, ON)
    wait(0.3)
    set_digital_output(1, OFF)

def close_gripper():
    # 너가 쓰던 방식: 채널1 펄스
    set_digital_output(1, ON)
    wait(0.3)
    set_digital_output(2, OFF)


# =========================
# Slot pose utilities
# =========================
def slot_pose(base, i, axis):
    x0, y0, z0, A0, B0, C0 = base
    x, y, z = x0, y0, z0
    if axis == 'x':
        x = x0 + i * DX
    elif axis == 'y':
        y = y0 + i * DY
    elif axis == 'z':
        z = z0 + i * DZ
    return posx(x, y, z, A0, B0, C0)

def app_pose_zup(base, i, axis):
    p = slot_pose(base, i, axis)
    return posx(p[0], p[1], p[2] + Z_UP, p[3], p[4], p[5])

def app_pose_xpull(base, i, axis, x_pull):
    p = slot_pose(base, i, axis)
    return posx(p[0] + x_pull, p[1], p[2], p[3], p[4], p[5])


# =========================
# Basic moves
# =========================
def go_home():
    movel(HOME_P, v=V_FAST, a=A_FAST)

def go_slot_zup(base, i, axis):
    p_app  = app_pose_zup(base, i, axis)
    p_work = slot_pose(base, i, axis)
    movel(p_app,  v=V_FAST, a=A_FAST)
    movel(p_work, v=V_SLOW, a=A_SLOW)

def leave_slot_zup(base, i, axis):
    p_app = app_pose_zup(base, i, axis)
    movel(p_app, v=V_FAST, a=A_FAST)

def go_slot_xpull(base, i, axis, x_pull):
    p_app  = app_pose_xpull(base, i, axis, x_pull)
    p_work = slot_pose(base, i, axis)
    movel(p_app,  v=V_FAST, a=A_FAST)
    movel(p_work, v=V_SLOW, a=A_SLOW)

def leave_slot_xpull(base, i, axis, x_pull):
    p_app = app_pose_xpull(base, i, axis, x_pull)
    movel(p_app, v=V_FAST, a=A_FAST)


# =========================
# Force / Compliance helpers
# =========================
def start_force():
    # 너 코드의 파라미터 유지
    task_compliance_ctrl()
    set_stiffnessx([1000,1000,1000,100,100,100])
    set_desired_force([0,0,-20,0,0,0],
                      [0,0,  1,0,0,0],
                      mod=DR_FC_MOD_ABS)
    wait(0.2)

def end_force():
    release_force(time=0.0)
    release_compliance_ctrl()

def z_up_rel():
    movel(posx(0,0,10,0,0,0), v=V_ALIGN, a=A_ALIGN, mod=DR_MV_MOD_REL)

def z_down_rel():
    movel(posx(0,0,-12,0,0,0), v=V_ALIGN, a=A_ALIGN, mod=DR_MV_MOD_REL)


# =========================
# Align algorithms (merged)
# =========================
def xy_check_slot(max_time=6.0):
    # 안전장치: 타임아웃 포함
    start_force()
    t0 = get_time()   # DRL에 get_time()이 없다면, 대신 카운터로 반복 횟수 제한 사용

    while True:
        pose, sol = get_current_posx(DR_BASE)
        x, y, z, rx, ry, rz = pose
        fx, fy, fz, tx, ty, tz = get_tool_force()

        # 성공(예시): 충분히 삽입 + 힘 안정
        if z <= 65.0 and fz >= 1.0:
            break

        # 타임아웃(환경에 따라 get_time 미지원이면 반복횟수로 대체)
        if (get_time() - t0) > max_time:
            break

        if fz >= 5 and z > 65.0:
            dx = 0
            dy = 0
            if tx > 0: dx = +3
            elif tx < 0: dx = -3
            if ty > 0: dy = +3
            elif ty < 0: dy = -3

            end_force()
            z_up_rel()
            movel(posx(dx, dy, 0, 0, 0, 0), v=V_ALIGN, a=A_ALIGN, mod=DR_MV_MOD_REL)
            z_down_rel()
            start_force()

        wait(0.05)

    end_force()


def spiral_check_slot():
    best_angle = 0.0
    min_torque = 999999.0

    start_force()

    for angle in [-3, -2, -1, 0, 1, 2, 3]:
        end_force()

        movej([0,0,0,0,0,angle], mod=DR_MV_MOD_REL)
        wait(0.1)

        fx, fy, fz, tx, ty, tz = get_tool_force()
        torque_score = abs(tx) + abs(ty)

        if torque_score < min_torque:
            min_torque = torque_score
            best_angle = angle

        # 복귀(누적 방지)
        movej([0,0,0,0,0,-angle], mod=DR_MV_MOD_REL)
        wait(0.05)

        start_force()

    end_force()
    movej([0,0,0,0,0,best_angle], mod=DR_MV_MOD_REL)


def check_slot():
    # 너 코드 파라미터 유지
    Z_SUCCESS = 65.0
    FZ_CONTACT = 2.0
    TORQUE_TH = 0.6
    ROT_TEST_ANGLE = 1.0
    ROT_RESPONSE_TH = 0.3

    start_force()

    # 접촉 대기
    while True:
        _, _, fz1, _, _, _ = get_tool_force()
        if fz1 >= 0.5:
            break

    pose, _ = get_current_posx(DR_BASE)
    x,y,z,rx,ry,rz = pose
    fx, fy, fz, tx, ty, tz = get_tool_force()

    problem_detected = (
        z > Z_SUCCESS and
        fz > FZ_CONTACT and
        (abs(tx) + abs(ty)) > TORQUE_TH
    )

    if not problem_detected:
        end_force()
        return

    end_force()

    # 회전 반응 테스트
    movej([0,0,0,0,0,ROT_TEST_ANGLE], mod=DR_MV_MOD_REL)
    wait(0.1)
    fx2, fy2, fz2, tx2, ty2, tz2 = get_tool_force()

    movej([0,0,0,0,0,-ROT_TEST_ANGLE], mod=DR_MV_MOD_REL)
    wait(0.1)

    delta_torque = abs(tx2 - tx) + abs(ty2 - ty)

    if delta_torque > ROT_RESPONSE_TH:
        spiral_check_slot()
    else:
        xy_check_slot(max_time=6.0)


# =========================
# Task sequences
# =========================
def pick_from_shelf1(base, i, axis, x_pull):
    open_gripper()
    wait(0.2)

    go_slot_xpull(base, i, axis, x_pull)

    close_gripper()
    wait(0.3)

    leave_slot_xpull(base, i, axis, x_pull)

def inspect_and_align_at_shelf2(base, i, axis):
    go_slot_zup(base, i, axis)

    # 병합 포인트: 정렬 수행
    check_slot()

    wait(INSPECT_TIME)
    leave_slot_zup(base, i, axis)

def place_to_shelf3(base, i, axis):
    go_slot_zup(base, i, axis)

    open_gripper()
    wait(0.3)

    leave_slot_zup(base, i, axis)


def do_homing():
    pass


def main():
    s1_idx = 0
    s2_idx = 0
    s3_idx = 0

    go_home()

    pick_from_shelf1(S1_BASE, s1_idx, S1_AXIS, X_PULL)
    go_home()

    inspect_and_align_at_shelf2(S2_BASE, s2_idx, S2_AXIS)

    place_to_shelf3(S3_BASE, s3_idx, S3_AXIS)
    go_home()

    do_homing()
    go_home()

main()

import rclpy
import threading
import os
import yaml
from ament_index_python.packages import get_package_share_directory
from std_msgs.msg import Float64MultiArray

from dsr_msgs2.srv import MoveStop  # ✅ MoveStop service (dsr_msgs2)

import DR_init

# =========================================================
# 0. Global Setup & Initialization
# =========================================================
ROBOT_ID = "dsr01"
ROBOT_MODEL = "m0609"
ROBOT_TOOL = "Tool Weight"
ROBOT_TCP  = "GripperDA_v1"

DR_init.__dsr__id = ROBOT_ID
DR_init.__dsr__model = ROBOT_MODEL

CONFIG = {}

# ✅ stop client + node를 전역으로 잡아두면, 어디서든 emergency_stop_motion() 호출 가능
_stop_cli = None
_MAIN_NODE = None

# =========================================================
# Config
# =========================================================
def load_config():
    global CONFIG
    try:
        config_path = "/home/markch/cobot_ws/src/project_hit/config/pose_config.yaml"
        if not os.path.exists(config_path):
            print(f"Warning: Source config not found at {config_path}. Trying package share...")
            pkg_path = get_package_share_directory('project_hit')
            config_path = os.path.join(pkg_path, 'config', 'pose_config.yaml')

        print(f"Loading configuration from: {config_path}")
        with open(config_path, 'r') as f:
            CONFIG.update(yaml.safe_load(f))
        print("Configuration loaded successfully.")
    except Exception as e:
        print(f"ERROR: Failed to load configuration: {e}")
        CONFIG.clear()

def get_config_val(path_str, default=None):
    keys = path_str.split('.')
    val = CONFIG
    try:
        for k in keys:
            val = val[k]
        return val
    except (KeyError, TypeError):
        print(f"Config Key Missing: {path_str}")
        return default

# =========================================================
# Robot init
# =========================================================
def initialize_robot():
    from DSR_ROBOT2 import set_tool, set_tcp
    set_tool(ROBOT_TOOL)
    set_tcp(ROBOT_TCP)

# =========================================================
# ROS2 Sub Callback Data
# =========================================================
latest_force = None     # [fx, fy, fz, mx, my, mz]
latest_posx  = None     # [x, y, z, rx, ry, rz]

def force_callback(msg):
    global latest_force
    latest_force = msg.data

def posx_callback(msg):
    global latest_posx
    latest_posx = msg.data

def spin_thread(node):
    executor = rclpy.executors.SingleThreadedExecutor()
    executor.add_node(node)
    executor.spin()

# =========================================================
# Motion constants
# =========================================================
VEL_LINEAR_FAST = 70
ACC_LINEAR_FAST = 70
VEL_LINEAR_APPROACH = 20
ACC_LINEAR_APPROACH = 20

VEL_JOINT_DEFAULT = 70
ACC_JOINT_DEFAULT = 70

# =========================================================
# Helpers
# =========================================================
def log_info(step, msg):
    print(f"[INFO] [{step}] {msg}")

def gripper_open():
    from DSR_ROBOT2 import set_digital_output, wait, ON, OFF
    set_digital_output(2, ON); wait(1.00); set_digital_output(2, OFF)

def gripper_close():
    from DSR_ROBOT2 import set_digital_output, wait, ON, OFF
    set_digital_output(1, ON); wait(1.00); set_digital_output(1, OFF)

def move_joint(q):
    from DSR_ROBOT2 import movej, posj
    movej(posj(q), vel=VEL_JOINT_DEFAULT, acc=ACC_JOINT_DEFAULT)

def move_home_joint():
    from DSR_ROBOT2 import movej, posj
    home_joint = get_config_val('poses.home_joint', [0,0,90,0,90,0])
    movej(posj(home_joint), vel=VEL_JOINT_DEFAULT, acc=ACC_JOINT_DEFAULT)

def _extract_posx6(p):
    """
    get_current_posx() 반환이
      - [x,y,z,rx,ry,rz]
      - ([x,y,z,rx,ry,rz], sol)
      - [[...], sol]
    등 섞여도 안전하게 6개만 뽑기
    """
    try:
        if len(p) >= 6 and isinstance(p[0], (int, float)):
            return float(p[0]), float(p[1]), float(p[2]), float(p[3]), float(p[4]), float(p[5])
    except Exception:
        pass
    try:
        if len(p) >= 1 and hasattr(p[0], '__len__') and len(p[0]) >= 6:
            return float(p[0][0]), float(p[0][1]), float(p[0][2]), float(p[0][3]), float(p[0][4]), float(p[0][5])
    except Exception:
        pass
    raise RuntimeError(f"Cannot extract 6D pose from get_current_posx(). Data: {p}")

def _wrap_deg(a):
    while a > 180.0: a -= 360.0
    while a < -180.0: a += 360.0
    return a

def _pose_from_current():
    from DSR_ROBOT2 import get_current_posx
    p = get_current_posx()
    x, y, z, A, B, C = _extract_posx6(p)
    return (x, y, z, A, B, C)

def _pose_same(p6):
    from DSR_ROBOT2 import posx
    x, y, z, A, B, C = p6
    return posx([x, y, z, A, B, C])

def _pose_tilt_from_pose(p6, pitch_delta):
    from DSR_ROBOT2 import posx
    x, y, z, A, B, C = p6
    B2 = _wrap_deg(B + pitch_delta)
    return posx([x, y, z, A, B2, C])

# =========================================================
# MoveStop(QSTOP=1)
# =========================================================
def init_move_stop_client(node):
    global _stop_cli
    if _stop_cli is not None:
        return

    service_name = f"/{ROBOT_ID}/motion/move_stop"  # ✅ 여기만 네 환경 이름에 맞추면 됨
    _stop_cli = node.create_client(MoveStop, service_name)

    if not _stop_cli.wait_for_service(timeout_sec=2.0):
        node.get_logger().warn(f"[MoveStop] service not available: {service_name}")

def emergency_stop_motion(node=None):
    """
    ✅ 즉시 정지: MoveStop(QSTOP=1)
    node 인자를 안 주면 전역 _MAIN_NODE 사용
    """
    global _stop_cli, _MAIN_NODE
    if node is None:
        node = _MAIN_NODE

    if node is None:
        print("[WARN] emergency_stop_motion: node is None")
        return

    if _stop_cli is None:
        init_move_stop_client(node)

    if _stop_cli is None:
        print("[WARN] emergency_stop_motion: MoveStop client not ready")
        return

    try:
        req = MoveStop.Request()
        req.stop_mode = 1  # ✅ QSTOP(1)
        _stop_cli.call_async(req)
    except Exception as e:
        print(f"[WARN] emergency_stop_motion(MoveStop) failed: {e}")

# =========================================================
# Force-based collision + REL step move
# =========================================================
def detect_collision_fz(th=15.0):
    global latest_force
    if latest_force is None:
        return False
    fz = float(latest_force[2])
    return abs(fz) > th

def movel_rel_step(rel6_total, step_mm=5.0, vel=VEL_LINEAR_FAST, acc=ACC_LINEAR_FAST, node=None, th=15.0):
    """
    ✅ REL 이동을 step으로 쪼개서 자주 force 체크
    """
    from DSR_ROBOT2 import movel, posx, DR_MV_MOD_REL, wait

    dx, dy, dz, dA, dB, dC = rel6_total

    def _split(v):
        if v == 0:
            return (0, 0.0)
        n = int(abs(v) // step_mm)
        r = abs(v) - n * step_mm
        return (n, r)

    nx, rx = _split(dx)
    ny, ry = _split(dy)
    nz, rz = _split(dz)

    def _apply_step(sx, sy, sz):
        if detect_collision_fz(th):
            emergency_stop_motion(node)
            return False
        movel(posx([sx, sy, sz, 0, 0, 0]), vel=vel, acc=acc, mod=DR_MV_MOD_REL)
        wait(0.01)
        if detect_collision_fz(th):
            emergency_stop_motion(node)
            return False
        return True

    if dx != 0:
        sx = step_mm if dx > 0 else -step_mm
        for _ in range(nx):
            if not _apply_step(sx, 0, 0): return False
        if rx > 0 and not _apply_step((rx if dx > 0 else -rx), 0, 0): return False

    if dy != 0:
        sy = step_mm if dy > 0 else -step_mm
        for _ in range(ny):
            if not _apply_step(0, sy, 0): return False
        if ry > 0 and not _apply_step(0, (ry if dy > 0 else -ry), 0): return False

    if dz != 0:
        sz = step_mm if dz > 0 else -step_mm
        for _ in range(nz):
            if not _apply_step(0, 0, sz): return False
        if rz > 0 and not _apply_step(0, 0, (rz if dz > 0 else -rz)): return False

    if any(abs(v) > 0 for v in [dA, dB, dC]):
        if detect_collision_fz(th):
            emergency_stop_motion(node); return False
        movel(posx([0, 0, 0, dA, dB, dC]), vel=vel, acc=acc, mod=DR_MV_MOD_REL)
        wait(0.01)
        if detect_collision_fz(th):
            emergency_stop_motion(node); return False

    return True

# =========================================================
# MAIN TASK (Stage A + Stage B)
# =========================================================
def perform_task(node):
    from DSR_ROBOT2 import movel, get_current_posx,posx, wait, DR_MV_MOD_REL, movej, posj

    log_info("Init", "Starting Task Sequence...")

    # ----- Config Load -----
    JOINT_POSES_SHELF_1 = get_config_val('poses.shelf_1.joint_poses', [])
    JOINT_POSES_SHELF_2 = get_config_val('poses.shelf_2.joint_poses', [])
    DROP_ZONE_JOINT     = get_config_val('poses.drop_zone_joint', [])
    Q_WAYPOINT_TRANSITION = get_config_val('poses.transition_waypoint')

    OFFSET_S1_APPROACH_X = get_config_val('poses.shelf_1.approach_x_offset', 20.0)
    OFFSET_S1_RETRACT_X  = get_config_val('poses.shelf_1.retract_x_offset', -10.0)
    WAIT_GRIPPER_STABILIZE_SEC = get_config_val('poses.shelf_1.wait_stabilize_sec', 0.5)

    ANGLE_S3_TILT_DEG = get_config_val('poses.shelf_3_tilt.angle_deg', 20.0)
    DIR_S3_TILT_SIGN  = get_config_val('poses.shelf_3_tilt.direction_sign', -1.0)

    cycle_count = min(len(JOINT_POSES_SHELF_1), len(JOINT_POSES_SHELF_2), 3)

    # ----- Home -----
    log_info("Home", "Moving to Home Joint Pose...")
    move_home_joint()
    wait(0.3)

    # =========================================================
    # Stage A (너가 쓰던 것 그대로, 단 get_current_posx 수정 부분만 안전화)
    # =========================================================
    log_info("Stage A", f"Starting Shelf 1 <-> Shelf 2 Loop ({cycle_count} cycles)")

    for i in range(cycle_count):
        step_id = f"A-{i+1}"

        # Pick Shelf1
        log_info(step_id, f"Opening Gripper & Moving to Shelf 1 Pose {i+1}")
        gripper_open(); wait(0.1)

        log_info(step_id, f"Joint Move -> {JOINT_POSES_SHELF_1[i]}")
        move_joint(JOINT_POSES_SHELF_1[i])

        entry_point = get_current_posx()
        entry_point = [list(entry_point[0]),entry_point[1]]

        if cycle_count == 1:
            entry_point[0][0] = entry_point[0][0]
        else:
            entry_point[0][0] = entry_point[0][0] + 12

        if cycle_count == 2:
            entry_point[0][1] = entry_point[0][1] - 133
        elif cycle_count == 0:
            entry_point[0][1] = entry_point[0][1] - 60
        else:
            entry_point[0][1] = entry_point[0][1] - 75

        entry_point[0][2] = entry_point[0][2] - 25

        movel(entry_point[0], v=70, a=70)


        # approach/retract X는 네 로직 유지 (REL로 처리)
        movel(posx([OFFSET_S1_APPROACH_X, 0, 0, 0, 0, 0]), v=VEL_LINEAR_APPROACH, a=ACC_LINEAR_APPROACH, mod=DR_MV_MOD_REL)
        wait(WAIT_GRIPPER_STABILIZE_SEC)

        log_info(step_id, "Gripper CLOSE")
        gripper_close(); wait(0.2)

        movel(posx([OFFSET_S1_RETRACT_X, 0, 0, 0, 0, 0]), v=VEL_LINEAR_APPROACH, a=ACC_LINEAR_APPROACH, mod=DR_MV_MOD_REL)
        wait(0.1)

        # Move to Shelf2
        log_info(step_id, f"Moving to Shelf 2 Pose {i+1}")

        point_away = posj(-29, 18, 69, 0, 92, -29)
        movej(point_away, vel=100, acc=100)
        JOINT_POSES_SHELF_1[i][2] = JOINT_POSES_SHELF_1[i][2]  + 30

        # ⚠️ 너가 JOINT_POSES_SHELF_1[i][2] 수정하던건 원본 데이터 파괴라 비추
        # 필요하면 복사본을 써.
        
        movej(JOINT_POSES_SHELF_2[i], vel=100, acc=100)
        wait(0.2)

        # Place (임시 삽입)
        movel(posx([0, 0, -30, 0, 0, 0]), vel=VEL_LINEAR_APPROACH, acc=ACC_LINEAR_APPROACH, mod=DR_MV_MOD_REL)
        wait(0.5)

        gripper_open()
        movel(posx([0, 0, 100, 0, 0, 0]), vel=VEL_LINEAR_FAST, acc=ACC_LINEAR_FAST, mod=DR_MV_MOD_REL)
        wait(0.5)

        log_info(step_id, "Stage A cycle completed")

    # =========================================================
    # Stage B (MoveStop(QSTOP=1) + step move + pending drop)
    # =========================================================
    log_info("Stage B", f"Starting Stage B ({cycle_count} cycles)")

    import random
    results = [True, True, False][:cycle_count]
    random.shuffle(results)

    holding = False
    pending_drop = False
    COLLISION_FZ_TH = 15.0

    for i in range(cycle_count):
        step_id = f"B-{i+1}"
        is_success = results[i]

        # pending drop 처리
        if pending_drop:
            if holding and DROP_ZONE_JOINT:
                log_info(step_id, "Pending drop -> go DROP_ZONE and release")
                try:
                    move_joint(DROP_ZONE_JOINT)
                    wait(0.1)
                    gripper_open()
                    holding = False
                    pending_drop = False
                    log_info(step_id, "Pending drop done.")
                except Exception as e:
                    log_info(step_id, f"Pending drop failed (maybe SERVO OFF). err={e}")
                    continue
            else:
                pending_drop = False

        # move to shelf2 pick
        log_info(step_id, f"Move to Shelf2 pick pose {i+1}")
        move_joint(JOINT_POSES_SHELF_2[i])
        wait(0.01)

        if detect_collision_fz(COLLISION_FZ_TH):
            log_info(step_id, "Collision right after move_joint (pick pose)")
            emergency_stop_motion(node)
            continue

        # descend
        ok = movel_rel_step([0, 0, -50, 0, 0, 0], step_mm=5.0,
                            vel=VEL_LINEAR_FAST, acc=ACC_LINEAR_FAST,
                            node=node, th=COLLISION_FZ_TH)
        if not ok:
            log_info(step_id, "Collision while descending")
            pending_drop = holding
            continue

        # grip
        log_info(step_id, "Gripper CLOSE")
        gripper_close()
        holding = True

        # lift
        ok = movel_rel_step([0, 0, 50, 0, 0, 0], step_mm=5.0,
                            vel=VEL_LINEAR_FAST, acc=ACC_LINEAR_FAST,
                            node=node, th=COLLISION_FZ_TH)
        if not ok:
            log_info(step_id, "Collision while lifting -> pending_drop")
            pending_drop = True
            continue

        # transition move
        if Q_WAYPOINT_TRANSITION:
            log_info(step_id, "Move to Transition Waypoint")
            try:
                move_joint(Q_WAYPOINT_TRANSITION)
                wait(0.01)
                if detect_collision_fz(COLLISION_FZ_TH):
                    raise RuntimeError("Collision after transition move")
            except Exception as e:
                log_info(step_id, f"Collision/Move error at transition: {e}")
                emergency_stop_motion(node)
                pending_drop = True
                continue

        # success/fail
        if is_success:
            cur6 = list(_pose_from_current())
            cur6[1] += 200  # ✅ Y+120

            p_work = _pose_same(cur6)
            p_tilt = _pose_tilt_from_pose(cur6, DIR_S3_TILT_SIGN * ANGLE_S3_TILT_DEG)

            log_info(step_id, f"[SUCCESS] Tilt + Drop @ Y+120 (tilt={DIR_S3_TILT_SIGN * ANGLE_S3_TILT_DEG}deg)")
            movel(p_tilt, vel=VEL_LINEAR_APPROACH, acc=ACC_LINEAR_APPROACH)
            wait(0.01)

            if detect_collision_fz(COLLISION_FZ_TH):
                log_info(step_id, "Collision during tilt -> pending_drop")
                emergency_stop_motion(node)
                pending_drop = True
                continue

            gripper_open()
            holding = False

            movel(p_work, vel=VEL_LINEAR_APPROACH, acc=ACC_LINEAR_APPROACH)
            wait(0.01)

            if detect_collision_fz(COLLISION_FZ_TH):
                log_info(step_id, "Collision during restore")
                emergency_stop_motion(node)
                continue

        else:
            log_info(step_id, "[FAIL] Drop at Transition (OPEN only)")
            gripper_open()
            holding = False

            ok = movel_rel_step([0, 0, 50, 0, 0, 0], step_mm=5.0,
                                vel=VEL_LINEAR_FAST, acc=ACC_LINEAR_FAST,
                                node=node, th=COLLISION_FZ_TH)
            if not ok:
                log_info(step_id, "Collision while retract after FAIL -> pending_drop")
                pending_drop = True
                continue

        log_info(step_id, f"Stage B cycle completed (success={is_success})")

    log_info("End", "Moving Home (after Stage B)")
    move_home_joint()
    log_info("End", "All tasks completed.")

# =========================================================
# Main
# =========================================================
def main(args=None):
    global _MAIN_NODE

    rclpy.init(args=args)
    load_config()

    node = rclpy.create_node("task_node_integrated", namespace=ROBOT_ID)
    _MAIN_NODE = node  # ✅ 전역에 저장
    DR_init.__dsr__node = node

    init_move_stop_client(node)

    node.create_subscription(Float64MultiArray, "/tool_force", force_callback, 10)
    node.create_subscription(Float64MultiArray, "/current_posx", posx_callback, 10)

    t = threading.Thread(target=spin_thread, args=(node,), daemon=True)
    t.start()

    try:
        initialize_robot()
        perform_task(node)

    except KeyboardInterrupt:
        print("\nShutting down task node...")
        try:
            print("Safety Homing Triggered...")
            move_home_joint()
        except Exception as home_err:
            print(f"Failed to safety home: {home_err}")

    except Exception as e:
        print(f"Unexpected error: {e}")

    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == "__main__":
    main()

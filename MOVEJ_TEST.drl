# ============================
# Stage A: Shelf1<->Shelf2 : movej로 3번 왕복 (HOME 출발)
#   - HOME에서 출발할 때 그리퍼 OPEN
#   - Shelf1 도착 후: X +20 -> wait 0.5 -> CLOSE -> X -10 -> Shelf2 이동
#   - Shelf2에서 검사 후 OPEN (놓기)
#
# Stage B: Shelf2->Shelf3 : movel로 3번 직선 운반
#   - Shelf2: 반복(i)마다 x + 60
#   - Shelf3: 반복(i)마다 x - 60
# ============================

Z_UP = 100.0
INSPECT_TIME = 2.0

V_FAST = 70
A_FAST = 70
V_SLOW = 20
A_SLOW = 20

# movej 속도/가속
VJ = 70
AJ = 70

HOME_P = posx(367.22, 3.83, 201.28, 158.41, 179.96, 158.79)

S2_BASE = (429.80, -258.59, 185.82, 115.72, -179.93, 116.62)  # Shelf2 slot0 (posx)
S3_BASE = (429.06,  213.83,  87.06, 152.93,  179.97, 155.34)  # Shelf3 slot0 (posx)

# Stage B step
S2_STEP_X = 60.0
S3_STEP_X = -60.0

# Shelf1 pick micro motion (Stage A)
S1_PICK_PUSH_X = 20.0     # Shelf1 도착 후 +20
S1_PICK_PULL_X = -10.0    # 잡은 후 -10
S1_BEFORE_CLOSE_WAIT = 0.5


def do_homing():
    pass


# -------------------------
# Gripper
# -------------------------
def open_gripper():
    set_digital_output(2, ON)
    wait(1.00)
    set_digital_output(2, OFF)

def close_gripper():
    set_digital_output(1, ON)
    wait(1.00)
    set_digital_output(1, OFF)


# -------------------------
# MOVEJ targets (이미 티칭한 값 사용)
# -------------------------
q_s1 = [
    [30.62, 18.12, 122.74, -146.41, 57.81, 161.67],
    [40.95, 24.14, 113.02, -133.93, 59.29, 152.80],
    [49.59, 30.45, 102.15, -123.56, 61.19, 144.29],
]
q_s2 = [
    [-31.45, 19.05, 69.88, 0.07, 91.00, -30.92],
    [-28.24, 27.55, 54.35, 0.11, 98.04, -27.66],
    [-25.60, 37.51, 39.08, 0.17, 103.36, -24.97],
]


def goj(q):
    movej(q, v=VJ, a=AJ)

def go_home():
    movel(HOME_P, v=V_FAST, a=A_FAST)


# -------------------------
# ✅ Robust: 현재 TCP posx를 어떤 형태로 받아도 6개로 뽑기
# -------------------------
def _extract_posx6(p):
    # 케이스1) p 자체가 [x,y,z,a,b,c] 형태
    try:
        if (len(p) >= 6):
            return p[0], p[1], p[2], p[3], p[4], p[5]
    except:
        pass

    # 케이스2) p가 (posx6, something) 형태 → 첫 번째 요소를 다시 풀기
    try:
        if (len(p) >= 1):
            p0 = p[0]
            if (len(p0) >= 6):
                return p0[0], p0[1], p0[2], p0[3], p0[4], p0[5]
    except:
        pass

    # 여기까지 왔으면 형태가 다름 → 팝업으로 확인 후 중단
    tp_popup("get_current_posx() format unexpected:\n" + str(p))
    # 안전하게 예외 발생(환경에 따라 raise 지원 안 하면 무한 루프/stop으로 대체 가능)
    raise Exception("Cannot extract 6D pose from get_current_posx()")


def move_rel_x(dx, v=V_SLOW, a=A_SLOW):
    """
    현재 TCP 기준으로 X만 dx 만큼 직선 이동 (movel)
    """
    p = get_current_posx()
    x, y, z, A, B, C = _extract_posx6(p)
    movel(posx(x + dx, y, z, A, B, C), v=v, a=a)


# -------------------------
# Stage B: MOVEL pose helpers
# -------------------------
def s2_work_pose(i):
    x0, y0, z0, A0, B0, C0 = S2_BASE
    return posx(x0 + i * S2_STEP_X, y0, z0, A0, B0, C0)

def s2_app_pose(i):
    x0, y0, z0, A0, B0, C0 = S2_BASE
    return posx(x0 + i * S2_STEP_X, y0, z0 + Z_UP, A0, B0, C0)

def s3_work_pose(i):
    x0, y0, z0, A0, B0, C0 = S3_BASE
    return posx(x0 + i * S3_STEP_X, y0, z0, A0, B0, C0)

def s3_app_pose(i):
    x0, y0, z0, A0, B0, C0 = S3_BASE
    return posx(x0 + i * S3_STEP_X, y0, z0 + Z_UP, A0, B0, C0)


def movel_pick_s2(i):
    movel(s2_app_pose(i),  v=V_FAST, a=A_FAST)
    movel(s2_work_pose(i), v=V_SLOW, a=A_SLOW)
    wait(0.2)

    close_gripper()
    wait(0.2)

    movel(s2_app_pose(i),  v=V_FAST, a=A_FAST)
    wait(0.1)


def movel_place_s3(i):
    movel(s3_app_pose(i),  v=V_FAST, a=A_FAST)
    movel(s3_work_pose(i), v=V_SLOW, a=A_SLOW)
    wait(0.2)

    open_gripper()
    wait(0.2)

    movel(s3_app_pose(i),  v=V_FAST, a=A_FAST)
    wait(0.1)


# ============================================================
# Stage A: HOME -> Shelf1 pick(미세이동 포함) -> Shelf2 inspect/place -> 다시 Shelf1
# ============================================================
def stageA_s1_s2_roundtrip_3cycles():
    for i in range(3):
        go_home()
        wait(0.2)

        # Shelf1 가기 전: 그리퍼 열기
        open_gripper()
        wait(0.1)

        # Shelf1(i) 이동
        goj(q_s1[i])
        wait(0.2)

        # ✅ X +20 전진
        move_rel_x(S1_PICK_PUSH_X, v=V_SLOW, a=A_SLOW)

        # ✅ 닫기 전 0.5초 대기
        wait(S1_BEFORE_CLOSE_WAIT)

        # ✅ 집기
        close_gripper()
        wait(0.2)

        # ✅ 잡은 후 X -10 후퇴
        move_rel_x(S1_PICK_PULL_X, v=V_SLOW, a=A_SLOW)
        wait(0.1)

        # Shelf2(i) 이동 -> 검사 -> 내려놓기
        goj(q_s2[i])
        wait(0.2)

        wait(INSPECT_TIME)

        open_gripper()
        wait(0.2)

        # 다시 Shelf1로 (다음 cycle 준비)
        goj(q_s1[i])
        wait(0.2)


# ============================================================
# Stage B: Shelf2 -> Shelf3 (movel) x3
# ============================================================
def stageB_s2_s3_movel_3cycles():
    for i in range(3):
        movel_pick_s2(i)
        movel_place_s3(i)


def main():
    go_home()
    wait(0.5)

    stageA_s1_s2_roundtrip_3cycles()
    stageB_s2_s3_movel_3cycles()

    do_homing()
    go_home()

main()

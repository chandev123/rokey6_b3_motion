# ============================================================
# ✅ 완성본 전체 코드
#
# Stage A: Shelf1 <-> Shelf2 3회 왕복 (movej, HOME 반복 방문 X)
#   - HOME에서 시작 1번만
#   - 매 cycle:
#       (1) Shelf1(i) 이동
#       (2) X +20 전진 -> 0.5s 대기 -> 그리퍼 닫기 -> X -10 후퇴
#       (3) Shelf2(i) 이동 -> INSPECT_TIME 대기 -> 그리퍼 열어 내려놓기
#
# Stage B: Shelf2 -> Shelf3 3회 운반
#   - Shelf2 픽: movej(q_s2[i])  (확실히 도달 가능한 티칭값)
#   - Shelf3 플레이스: movej(q_mid)로 "항상 동일한 팔 모양" 도착
#       그 자리에서만 local movel (Z_UP 위/아래 + tilt)
#   - 이 방식은 IK branch 튐을 최소화해서 workspace 오류를 크게 줄임
# ============================================================

Z_UP = 100.0
INSPECT_TIME = 2.0

V_FAST = 70
A_FAST = 70
V_SLOW = 20
A_SLOW = 20

VJ = 70
AJ = 70

HOME_P = posx(367.22, 3.83, 201.28, 158.41, 179.96, 158.79)

# Shelf3 fixed point (참고용: q_mid와 같은 지점에서 측정한 값)
S3_BASE = (429.06, 213.83, 87.06, 152.93, 179.97, 155.34)

# ✅ 사용자 제공 중간(=Shelf3 안정) 관절 자세
q_mid = [26.01, 17.70, 87.27, 0.13, 75.06, 26.03]

# Stage A Shelf1 micro motion
S1_PICK_PUSH_X = 20.0
S1_PICK_PULL_X = -10.0
S1_BEFORE_CLOSE_WAIT = 0.5

# Stage B Shelf3 tilt (현재 q_mid 자세 기준 B에 덧붙이는 방식)
S3_PITCH_DELTA_DEG = 20.0   # 처음 10~20 추천, 안정되면 30~40로 올리기
S3_PITCH_SIGN = -1.0        # 방향 반대면 +1/-1 바꾸기


def do_homing():
    pass


# -------------------------
# Gripper
# -------------------------
def open_gripper():
    set_digital_output(2, ON)
    wait(1.00)
    set_digital_output(2, OFF)

def close_gripper():
    set_digital_output(1, ON)
    wait(1.00)
    set_digital_output(1, OFF)


# -------------------------
# MOVEJ targets (티칭값)
# -------------------------
q_s1 = [
    [30.62, 18.12, 122.74, -146.41, 57.81, 161.67],
    [40.95, 24.14, 113.02, -133.93, 59.29, 152.80],
    [49.59, 30.45, 102.15, -123.56, 61.19, 144.29],
]
q_s2 = [
    [-31.45, 19.05, 69.88, 0.07, 91.00, -30.92],
    [-28.24, 27.55, 54.35, 0.11, 98.04, -27.66],
    [-25.60, 37.51, 39.08, 0.17, 103.36, -24.97],
]

def goj(q):
    movej(q, v=VJ, a=AJ)

def go_home():
    movel(HOME_P, v=V_FAST, a=A_FAST)


# -------------------------
# Robust current posx extractor
# -------------------------
def _extract_posx6(p):
    # case1: [x,y,z,a,b,c]
    try:
        if len(p) >= 6:
            return p[0], p[1], p[2], p[3], p[4], p[5]
    except:
        pass

    # case2: ([x,y,z,a,b,c], sol)
    try:
        if len(p) >= 1:
            p0 = p[0]
            if len(p0) >= 6:
                return p0[0], p0[1], p0[2], p0[3], p0[4], p0[5]
    except:
        pass

    tp_popup("get_current_posx() format unexpected:\n" + str(p))
    raise Exception("Cannot extract 6D pose from get_current_posx()")


def _wrap_deg(a):
    while a > 180.0:
        a = a - 360.0
    while a < -180.0:
        a = a + 360.0
    return a


# -------------------------
# Relative move X (Stage A pick micro)
# -------------------------
def move_rel_x(dx, v=V_SLOW, a=A_SLOW):
    p = get_current_posx()
    x, y, z, A, B, C = _extract_posx6(p)
    movel(posx(x + dx, y, z, A, B, C), v=v, a=a)


# -------------------------
# Stage B local pose builders from current
# -------------------------
def _pose_from_current():
    p = get_current_posx()
    x, y, z, A, B, C = _extract_posx6(p)
    return (x, y, z, A, B, C)

def _pose_add_z(p6, dz):
    x, y, z, A, B, C = p6
    return posx(x, y, z + dz, A, B, C)

def _pose_same(p6):
    x, y, z, A, B, C = p6
    return posx(x, y, z, A, B, C)

def _pose_tilt_from_pose(p6, pitch_delta):
    x, y, z, A, B, C = p6
    B2 = _wrap_deg(B + pitch_delta)
    return posx(x, y, z, A, B2, C)


# ============================================================
# Stage A: Shelf1<->Shelf2 (HOME 반복 방문 없이) 3번 연속 왕복
# ============================================================
def stageA_s1_s2_roundtrip_3cycles_no_home():
    # 시작: HOME 1번만
    go_home()
    wait(0.3)

    for i in range(3):
        # 0) 집기 전 그리퍼 열기
        open_gripper()
        wait(0.1)

        # 1) Shelf1(i) 이동
        goj(q_s1[i])
        wait(0.2)

        # 2) +X 전진 -> 대기 -> 집기 -> -X 후퇴
        move_rel_x(S1_PICK_PUSH_X, v=V_SLOW, a=A_SLOW)
        wait(S1_BEFORE_CLOSE_WAIT)
        close_gripper()
        wait(0.2)
        move_rel_x(S1_PICK_PULL_X, v=V_SLOW, a=A_SLOW)
        wait(0.1)

        # 3) Shelf2(i) 이동 -> 검사 -> 내려놓기
        goj(q_s2[i])
        wait(0.2)

        wait(INSPECT_TIME)

        open_gripper()
        wait(0.2)


# ============================================================
# Stage B: Shelf2(i)에서 집기 -> q_mid로 이동 -> (local movel)로 Shelf3에 놓기
#   - Shelf3는 q_mid에서 "현재 posx"를 읽어 local하게만 movel 수행 (동일성/안정성↑)
# ============================================================
def stageB_s2_s3_pick_qs2_via_qmid_place_local_3cycles():
    for i in range(3):
        # 1) Shelf2(i) 픽 (movej)
        goj(q_s2[i])
        wait(0.2)

        close_gripper()
        wait(0.2)

        # 2) q_mid 경유 (항상 같은 팔 모양으로 Shelf3 영역 진입)
        goj(q_mid)
        wait(0.2)

        # 3) q_mid 위치에서 현재 posx를 기준으로 local approach/work 생성
        cur6 = _pose_from_current()
        p_app  = _pose_add_z(cur6, Z_UP)
        p_work = _pose_same(cur6)

        # 4) 접근/하강 (local movel)
        movel(p_app,  v=V_FAST, a=A_FAST)
        movel(p_work, v=V_SLOW, a=A_SLOW)
        wait(0.1)

        # 5) 같은 점에서만 tilt 후 놓기
        p_tilt = _pose_tilt_from_pose(cur6, S3_PITCH_SIGN * S3_PITCH_DELTA_DEG)
        movel(p_tilt, v=V_SLOW, a=A_SLOW)
        wait(0.1)

        open_gripper()
        wait(0.2)

        # 6) 원래 자세로 복귀 후 위로
        movel(p_work, v=V_SLOW, a=A_SLOW)
        movel(p_app,  v=V_FAST, a=A_FAST)
        wait(0.1)

        # 7) 다음 cycle 안정 시작을 위해 다시 q_mid
        goj(q_mid)
        wait(0.1)


def main():
    stageA_s1_s2_roundtrip_3cycles_no_home()
    stageB_s2_s3_pick_qs2_via_qmid_place_local_3cycles()

    do_homing()
    go_home()

main()
